#pragma once
#include <iostream>

using namespace std;

// Оголошення структури для вузла списку
struct Node
{
	int data;       // Дані вузла
	Node* next;     // Вказівник на наступний вузол
	Node() { data = 0; next = nullptr; } // Конструктор за замовчуванням
	Node(int x) { data = x; next = nullptr; } // Конструктор з параметром
};

// Оголошення класу "Стек"
class Stack
{
public:
	Node* Top;      // Вказівник на верхній елемент стеку
	

	// Конструктор за замовчуванням
	Stack()
	{
		Top = nullptr;  // Початкове значення вказівника - nullptr (пустий стек)
	}

	// Деструктор
	~Stack()
	{
		Node* temp = Top;   // Встановлення початкового вказівника на верхній елемент

		// Поки є елементи в стеці
		while (Top)
		{
			temp = Top;     // Зберігаємо поточний вузол
			Top = Top->next;    // Переходимо до наступного вузла
			delete temp;    // Видаляємо попередній вузол
		}
	}


	void push(int x);
	void push(Stack& p);
	void pop();
	void view();
	char top();
	bool empty();
};

// Реалізація методів класу "Стек"

// Додавання елементу у стек
void Stack::push(int x)
{
	Node* n_new = new Node(x);  // Створення нового вузла з переданим значенням
	n_new->next = Top;          // Новий вузол вказує на попередній верхній елемент
	Top = n_new;                // Початковий вказівник тепер вказує на новий вузол
}


// Видалення верхнього елементу зі стеку
void Stack::pop()
{
	// Якщо стек пустий
	if (!Top)
	{
		cout << "nothing to delete" << endl;   // Вивід повідомлення про порожній стек
	}
	else
	{
		Node* temp = Top;       // Зберігання початкового вказівника на верхній елемент
		Top = Top->next;        // Переходимо до наступного вузла (видаляємо верхній елемент)
		delete temp;            // Видаляємо попередній верхній елемент
	}
}

// Виведення всіх елементів стеку
void Stack::view()
{
	// Якщо стек пустий
	if (!Top)
	{
		cout << "stack is empty" << endl;   // Вивід повідомлення про порожній стек
	}
	else
	{
		const Node* temp = Top;     // Встановлення початкового вказівника на верхній елемент

		// Поки є елементи в стеці
		while (temp)
		{
			cout << temp->data << " ";  // Виведення даних поточного вузла
			temp = temp->next;          // Перехід до наступного вузла
		}
		cout << endl;   
	}
}

// Повернення значення верхнього елементу стеку
char Stack::top()
{
	return Top->data;   // Повернення значення верхнього елементу
}

// Перевірка на пустоту стеку
bool Stack::empty()
{
	return Top == nullptr;   // Повернення true, якщо стек порожній, і false - в іншому випадку
}

// Додавання стеку p у поточний стек
void Stack::push(Stack& p)
{
	// Якщо стек p не пустий і поточний стек не пустий
	if (!(p.empty() && empty()))
	{
		Node* temp = p.Top;     // Встановлення початкового вказівника на верхній елемент стеку p
		Node* pTop = p.Top;     // Зберігання початкового вказівника на верхній елемент стеку p

		// Поки є елементи в стеці p
		while (temp)
		{
			// Якщо є наступний елемент
			if (temp->next)
			{
				temp = pTop;    // Встановлення початкового вказівника на верхній елемент стеку p
				pTop = pTop->next;  // Переходимо до наступного вузла стеку p
			}
			else
			{
				temp->next = Top;   // Останній елемент стеку p вказує на верхній елемент поточного стеку
				Top = p.Top;        // Початковий вказівник поточного стеку вказує на верхній елемент стеку p
				break;              // Вихід з циклу
			}
		}
		p.Top = nullptr;    // Звільнення пам'яті, оскільки всі елементи стеку p тепер в поточному стеці
	}
}
